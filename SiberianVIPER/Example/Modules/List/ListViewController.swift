//
//  ListViewController.swift
//  SiberianVIPER
//
//  Created by Sergey Petrachkov on 25/12/2017.
//  Copyright (c) 2017 Sergey Petrachkov. All rights reserved.
//
//  This file was generated by the SergeyPetrachkov VIPER Xcode Templates so
//  you can apply VIPER architecture to your iOS projects
//

import UIKit
import SiberianVIPER
class ListDisplayManager: SiberianCollectionManager {
  var fetchManager: ListPresenterInput?
  public convenience init(provider: AnySiberianCollectionSource, delegate: SiberianCollectionDelegate?, fetchManager: ListPresenterInput?) {
    self.init(provider: provider, delegate: delegate)  
    self.fetchManager = fetchManager
  }
  
  
  func scrollViewWillEndDragging(_ scrollView: UIScrollView, withVelocity velocity: CGPoint, targetContentOffset: UnsafeMutablePointer<CGPoint>) {
    let bottomEdge = targetContentOffset.pointee.y + scrollView.frame.size.height
    if bottomEdge >= scrollView.contentSize.height {
      self.fetchManager?.fetch()
    }
  }
}
class ListViewController: UITableViewController {
  // MARK: - UI properties
 
  // MARK: - Essentials
  var presenter : ListPresenterInput?
  lazy var displayManager: ListDisplayManager? = { [weak self] in
    guard let strongSelf = self,
      let provider = strongSelf.presenter as? AnySiberianCollectionSource else {
        return nil
    }
    let manager = ListDisplayManager(provider: provider,
                                     delegate: strongSelf.presenter as? SiberianCollectionDelegate,
                                     fetchManager: strongSelf.presenter)
    
    
    return manager
  }()

  // MARK: Initializers
  override init(nibName nibNameOrNil: String?, bundle nibBundleOrNil: Bundle?) {
    super.init(nibName: nibNameOrNil, bundle: nibBundleOrNil)
  }
  required init?(coder aDecoder: NSCoder) {
    super.init(coder: aDecoder)
  }
  
  // MARK: - Setup
  private func setup() {
    self.tableView.tableFooterView = UIView()
    self.tableView.dataSource = self.displayManager
    self.tableView.delegate = self.displayManager
    self.refreshControl = UIRefreshControl()
    self.refreshControl?.addTarget(self, action: #selector(self.handleRefresh(_:)), for: .valueChanged)
    self.refreshControl?.tintColor = UIColor.darkGray
  }
  
  // MARK: - Lifecycle
  var refreshing: Bool = false
  override func viewDidLoad() {
    super.viewDidLoad()
    self.setup()
    self.presenter?.start()
  }
  
  // MARK: - Actions
  @objc fileprivate func handleRefresh(_ refreshControl: UIRefreshControl) {
    self.presenter?.refresh()
  }
  
  // MARK: - UIScrollViewDelegate
  
  override func scrollViewWillEndDragging(_ scrollView: UIScrollView,
                                 withVelocity velocity: CGPoint,
                                 targetContentOffset: UnsafeMutablePointer<CGPoint>) {
    let bottomEdge = targetContentOffset.pointee.y + scrollView.frame.size.height
    if bottomEdge >= scrollView.contentSize.height {
      DispatchQueue.global().asyncAfter(deadline: .now() + 0.3, execute: {
        self.presenter?.fetch()
      })
    }
  }
  
}
extension ListViewController : ListPresenterOutput {
  func didEnterPendingState(visible: Bool, blocking: Bool) {
    self.tableView.isUserInteractionEnabled = !blocking
    if visible {
      self.refreshControl?.beginRefreshing()
    }
  }
  
  func didExitPendingState() {
    self.tableView.isUserInteractionEnabled = true
    self.refreshControl?.endRefreshing()
  }
  func didChangeState(viewModel : List.DataContext.ViewModel) {
    if viewModel.changeSet.count == 0 {
      self.presenter?.exitPendingState()
      return
    }
    var newIndexPaths = [IndexPath]()
    var editedIndexPaths = [IndexPath]()
    var deletedIndexPaths = [IndexPath]()
    var shouldScrollToTop = false
    viewModel.changeSet.forEach({ change in
      switch change {
      case .new(let indexPath):
        if let indexPath = indexPath {
          newIndexPaths.append(indexPath)
        }
      case .edit(let indexPath):
        editedIndexPaths.append(indexPath)
      case .delete(let indexPath):
        deletedIndexPaths.append(indexPath)
      }
    })
    if deletedIndexPaths.count > 0 {
      shouldScrollToTop = true
    }
    if #available(iOS 11.0, *) {
      self.tableView.performBatchUpdates({
        if deletedIndexPaths.count > 0 {
          self.tableView.deleteRows(at: deletedIndexPaths, with: .automatic)
        }
        if newIndexPaths.count > 0 {
          self.tableView.insertRows(at: newIndexPaths, with: .automatic)
        }
        if editedIndexPaths.count > 0 {
          self.tableView.reloadRows(at: editedIndexPaths, with: .automatic)
        }
      }, completion: { result in
        print("list batch update ended with result: \(result) \n\rtotal: \(viewModel.items.count) \n\rnew:\(newIndexPaths.count) \n\rchanged: \(editedIndexPaths.count) \n\rdeleted: \(deletedIndexPaths.count)")
        if shouldScrollToTop, self.tableView.contentOffset.y > 120 {
          self.tableView.scrollToRow(at: IndexPath(row: 0, section: 0), at: .top, animated: true)
        }
        self.presenter?.exitPendingState()
      })
    } else {
      self.tableView.beginUpdates()
      if deletedIndexPaths.count > 0 {
        self.tableView.deleteRows(at: deletedIndexPaths, with: .right)
      }
      if newIndexPaths.count > 0 {
        self.tableView.insertRows(at: newIndexPaths, with: .top)
      }
      if editedIndexPaths.count > 0 {
        self.tableView.reloadRows(at: editedIndexPaths, with: .fade)
      }
      self.presenter?.exitPendingState()
      print("-OLD- : list batch update ended. \n\rtotal: \(viewModel.items.count) new:\(newIndexPaths.count) changed: \(editedIndexPaths.count) deleted: \(deletedIndexPaths.count)")
      self.tableView.endUpdates()
      return
    }
  }
}
